---
title: "Introduction to BMEmapping"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction to BMEmapping}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Introduction

The Bayesian Maximum Entropy (BME) framework offers a robust and versatile approach for space-time data analysis and uncertainty quantification. By integrating principles from Bayesian statistics and the maximum entropy formalism, BME enables the construction of optimal estimates for spatial or spatiotemporal processes in the presence of both precise (hard) and imprecise (soft) data. While hard data correspond to exact point-value measurements, soft data may take the flexible forms of intervals, probability distributions, or qualitative descriptors, making BME particularly well-suited for complex real-world datasets.

The **BMEmapping** R package provides a user-friendly implementation of core BME methodologies, facilitating geostatistical modeling, prediction, and data fusion. It allows for a systematic integration of heterogeneous data sources, incorporates prior knowledge, and supports variogram-based spatial modeling—essential tools for accurate and interpretable spatial interpolation.

Specifically, **BMEmapping** is designed to perform spatial interpolation at unobserved locations using both hard and soft-interval data. This vignette introduces the fundamental functionality of the package and guides users through its basic usage.

To begin, load the package with:

```{r echo=FALSE, warning=FALSE}
library(ggplot2)
```


```{r setup}
library(BMEmapping)
```


## Main Functions

The main functions available in **BMEmapping** include:

`prob_zk` - computes the numerical estimation of the posterior density of an unobserved location.

`posterior_plot` - plots the the posterior density of an unobserved location.

`bme_predict` - predicts the posterior mean/mode and variance of an unobserved location.

`bme_cv` - performs a cross-validation on the hard data to assess model performance.

`sim_cholesky` - simulates multiple independent sets of zero-mean Gaussian.


$~$

## A Data Example

To introduce the functionality of **BMEmapping**, we will look at a modeling problem for estimating reliability-targeted snow loads in the state of Utah. The `utah` data that is part of the package and can be accessed by the command

```{r}
data("utah")
head(utah)
```

and the documentation of the `utah` data can be found by invoking the command:

```{r eval=FALSE}
?utah
```

  
### Input Requirements

The **BMEmapping** functions require the following input arguments:

`x`: A vector specifying the geographic location(s) where predictions are to be made.

`ch`: A matrix or data frame containing the geographic coordinates of the hard data locations.

`cs`: A matrix or data frame containing the geographic coordinates of the soft-interval data locations.

`zh`: A vector of observed hard data values corresponding to the locations in `ch`.

`a`: A vector of lower bounds for the soft-interval data at locations `cs`.

`b`: A vector of upper bounds for the soft-interval data at locations `cs`.

### Variography

Before using `BMEmapping`, the user must fit a variogram model to the spatial data. This step involves specifying the type of variogram and its associated parameters:

* `model`: The variogram model type. Supported options are "exp" (Exponential), "sph" (Spherical), and "gau" (Gaussian). The appropriate model should be selected based on the spatial structure of the data.

* `nugget`: The nugget effect of the variogram, representing measurement error or microscale variation.

* `sill`: The sill of the variogram, indicating the plateau value of the semivariance.

* `range`: The range (or effective range) of the variogram, representing the distance beyond which spatial correlation becomes negligible.

A recommended tool for variogram modeling is the **gstat** package, which provides a robust suite of functions for fitting and analyzing variograms.

### Optional Parameters

* `nhmax`: Maximum number of nearby hard data points to include in the integration process.

* `nsmax`: Maximum number of nearby soft-interval data points to include in the integration process.

If these parameters are not specified, the function uses default values: `nhmax` = 10 and `nsmax` = 5. This means the integration step will automatically select the 10 nearest hard data points and the 5 nearest soft data points relative to each prediction location.


### BME Prediction

Using the `utah` dataset, you can prepare the necessary input variables as shown below. In this example, we designate **Location 1** as the **prediction location**.

```{r}
# prediction location
x <- data.matrix(utah[1, c("x", "y")])

# hard data locations
ch <- data.matrix(utah[2:20, c("x", "y")]) 

# soft data locations
cs <- data.matrix(utah[68:232, c("x", "y")])  

# hard data values
zh <- c(utah[2:20, c("center")])

# lower bounds
a <- c(utah[68:232, c("lower")]) 

# upper bounds
b <- c(utah[68:232, c("upper")]) 

# variogram model and parameters
model <- "sph"
nugget <- 0.1184
sill <- 0.3474
range <- 119197

# additional parameters
nsmax <- 5
nhmax <- 5

```


The `prob_zk` function accepts all the data and variogram input arguments explained above. The numerical estimation of the posterior density for location `x = (lat = 394835.1, lon = 4477333)` is computed as 
```{r}
zk <- prob_zk(x, ch, cs, zh, a, b, model, nugget, sill, range, nsmax, nhmax)

#show first 10 rows 
head(zk, 10)
```

The `posterior_plot` function accepts the same arguments as the `prob_zk` function. The posterior density for location `x = (lat = 394835.1, lon = 4477333)` can be shown by

```{r fig.width = 6, fig.height = 4, fig.align='center'}
posterior_plot(x, ch, cs, zh, a, b, model, nugget, sill, range, nsmax, nhmax)
```

The `bme_predict` function accepts the same arguments as the `prob_zk` function, with the addition of a `type` argument, which specifies the preferred type of prediction (either the posterior mean or mode). Using the data provided, we can predict the mean and mode of the posterior density at the location `x = (lat = 394835.1, lon = 4477333)` by:

```{r}
# posterior mode
bme_predict(x, ch, cs, zh, a, b, model, nugget, sill, range, nsmax, nhmax, type = "mode")

# posterior mean
bme_predict(x, ch, cs, zh, a, b, model, nugget, sill, range, nsmax, nhmax, type = "mean")
```


### Leave-One-Out Cross-Validation (LOOCV) for Model Evaluation

LOOCV is used to assess prediction accuracy by successively removing one hard data point at a time—where true values are known—and predicting its value using the remaining hard data and all of the soft-interval data. A variogram model is fitted to the reduced dataset, and the predicted value at the excluded location is compared to its observed value. Soft data locations are excluded from the validation set, as their true values are unobservable.

The `bme_cv` function performs LOOCV for at hard data locations and returns key performance metrics, including **mean error (ME)**, **mean absolute error (MAE)**, and **root mean squared error (RMSE)** of the prediction residuals. These statistics offer insight into the model’s bias, average prediction accuracy, and the variability of prediction errors, respectively.

Functionally, `bme_cv` accepts similar arguments as the `bme_predict` function. Given the necessary data inputs and variogram parameters, LOOCV can be applied to evaluate the posterior mean predictions as follows:

```{r eval=FALSE}
bme_cv(ch, cs, zh, a, b, model, nugget, sill, range, nsmax, nhmax, type = "mean")

#> [[1]]
#>    coord.1 coord.2    observed       mean   variance    residual fold
#> 2  379535.4 4422050  0.12258678 -0.3333805 0.15675334  0.45596732    1
#> 3  287875.9 4154157 -0.02302358  0.1533209 0.12043303 -0.17634452    2
#> 4  248027.5 4153048  0.50354362 -0.2105528 0.30524092  0.71409645    3
#> 5  626735.3 4352209 -0.68611327 -0.9842654 0.44350520  0.29815211    4
#> 6  623308.4 4508700 -0.53000397 -0.7064621 0.07245835  0.17645818    5
#> 7  593901.7 4496057 -0.71923519 -0.9121312 0.10925932  0.19289602    6
#> 8  587585.2 4529287 -1.31503404 -1.2120869 0.07988129 -0.10294709    7
#> 9  612294.9 4510746 -0.94879597 -0.6553507 0.04769710 -0.29344532    8
#> 10 568204.9 4530192 -1.39798035 -1.2248797 0.10526924 -0.17310063    9
#> 11 543765.9 4533337 -1.21900906 -0.7558048 0.09784625 -0.46320425   10
#> 12 548226.6 4494511 -1.24787225 -1.0361362 0.05110308 -0.21173607   11
#> 13 526248.0 4488851 -0.55027484 -0.3936822 0.09079546 -0.15659262   12
#> 14 542108.0 4528887 -1.06708711 -0.7325954 0.17585558 -0.33449168   13
#> 15 544762.0 4507810 -1.14044998 -1.1838506 0.06977316  0.04340066   14
#> 16 534699.6 4492216 -0.94551554 -0.6005826 0.03635184 -0.34493298   15
#> 17 516855.9 4523235 -0.83840015 -0.7223663 0.04373783 -0.11603383   16
#> 18 583549.9 4513697 -1.24671792 -1.1051491 0.10676869 -0.14156882   17
#> 19 510122.6 4516562 -0.65036211 -0.7024364 0.03414099  0.05207428   18
#> 20 504225.3 4503236 -0.37127802 -0.3966839 0.04861639  0.02540585   19

#> [[2]]
#>            ME       MAE     RMSE
#> 1 -0.02926037 0.2354131 0.288952
```


### Spatial Data Simulation

Spatial data simulation using the *Cholesky decomposition* of the covariance matrix is a reliable method for generating spatially correlated Gaussian data. It is particularly effective for producing a set of zero-mean, multivariate normal values that conform to a specified spatial covariance structure. This technique is most practical when working with a small number of hard data points (typically fewer than a few hundred), where the computational cost of decomposing the full covariance matrix remains manageable.

Given a set of spatial locations, `x` and a specified variogram model with its associated parameters (`model`, `nugget`, `sill`, `range`), the `sim_cholesky` function generates zero-mean Gaussian values at those locations that respect the defined spatial covariance structure.

```{r warning=FALSE}
x <- matrix(runif(10), ncol = 2)
model <- "sph"
nugget <- 0
sill <- 1
range <- 1

sim_cholesky(x, model, nugget, sill, range)
```

